"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8411],{6589:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>_,contentTitle:()=>l,default:()=>h,frontMatter:()=>p,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"contribute/development-guide/coding/extending-the-api/adding-features/controllers","title":"Controller","description":"A controller receives a request, then calls a use case, before finally returning a response.","source":"@site/docs/contribute/development-guide/coding/extending-the-api/adding-features/01-controllers.md","sourceDirName":"contribute/development-guide/coding/extending-the-api/adding-features","slug":"/contribute/development-guide/coding/extending-the-api/adding-features/controllers","permalink":"/template-fastapi-react/docs/contribute/development-guide/coding/extending-the-api/adding-features/controllers","draft":false,"unlisted":false,"editUrl":"https://github.com/equinor/template-fastapi-react/tree/main/documentation/docs/contribute/development-guide/coding/extending-the-api/adding-features/01-controllers.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"contribute","previous":{"title":"Adding features","permalink":"/template-fastapi-react/docs/contribute/development-guide/coding/extending-the-api/adding-features/"},"next":{"title":"Use cases","permalink":"/template-fastapi-react/docs/contribute/development-guide/coding/extending-the-api/adding-features/use-cases"}}');var n=o(4848),r=o(8453),d=o(1028);const i='from fastapi import APIRouter, Depends\n\nfrom authentication.authentication import auth_with_jwt\nfrom authentication.models import User\nfrom common.exception_handlers import ExceptionHandlingRoute\nfrom features.todo.repository.todo_repository import get_todo_repository\nfrom features.todo.repository.todo_repository_interface import TodoRepositoryInterface\nfrom features.todo.use_cases.add_todo import (\n    AddTodoRequest,\n    AddTodoResponse,\n    add_todo_use_case,\n)\nfrom features.todo.use_cases.delete_todo_by_id import (\n    DeleteTodoByIdResponse,\n    delete_todo_use_case,\n)\nfrom features.todo.use_cases.get_todo_all import GetTodoAllResponse, get_todo_all_use_case\nfrom features.todo.use_cases.get_todo_by_id import (\n    GetTodoByIdResponse,\n    get_todo_by_id_use_case,\n)\nfrom features.todo.use_cases.update_todo import (\n    UpdateTodoRequest,\n    UpdateTodoResponse,\n    update_todo_use_case,\n)\n\nrouter = APIRouter(tags=["todo"], prefix="/todos", route_class=ExceptionHandlingRoute)\n\n\n@router.post("", operation_id="create")\ndef add_todo(\n    data: AddTodoRequest,\n    user: User = Depends(auth_with_jwt),\n    todo_repository: TodoRepositoryInterface = Depends(get_todo_repository),\n) -> AddTodoResponse:\n    return add_todo_use_case(data=data, user_id=user.user_id, todo_repository=todo_repository)\n\n\n@router.get("/{id}", operation_id="get_by_id")\ndef get_todo_by_id(\n    id: str,\n    user: User = Depends(auth_with_jwt),\n    todo_repository: TodoRepositoryInterface = Depends(get_todo_repository),\n) -> GetTodoByIdResponse:\n    return get_todo_by_id_use_case(id=id, user_id=user.user_id, todo_repository=todo_repository)\n\n\n@router.delete("/{id}", operation_id="delete_by_id")\ndef delete_todo_by_id(\n    id: str,\n    user: User = Depends(auth_with_jwt),\n    todo_repository: TodoRepositoryInterface = Depends(get_todo_repository),\n) -> DeleteTodoByIdResponse:\n    return delete_todo_use_case(id=id, user_id=user.user_id, todo_repository=todo_repository)\n\n\n@router.get("", operation_id="get_all")\ndef get_todo_all(\n    user: User = Depends(auth_with_jwt), todo_repository: TodoRepositoryInterface = Depends(get_todo_repository)\n) -> list[GetTodoAllResponse]:\n    return get_todo_all_use_case(user_id=user.user_id, todo_repository=todo_repository)  # type: ignore\n\n\n@router.put("/{id}", operation_id="update_by_id")\ndef update_todo(\n    id: str,\n    data: UpdateTodoRequest,\n    user: User = Depends(auth_with_jwt),\n    todo_repository: TodoRepositoryInterface = Depends(get_todo_repository),\n) -> UpdateTodoResponse:\n    return update_todo_use_case(id=id, data=data, user_id=user.user_id, todo_repository=todo_repository)\n',a='import pytest\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\nfrom starlette.testclient import TestClient\n\nfrom data_providers.clients.client_interface import ClientInterface\n\n\nclass TestTodo:\n    @pytest.fixture(autouse=True)\n    def setup_database(self, test_client: ClientInterface):\n        test_client.insert_many(\n            [\n                {"_id": "1", "id": "1", "title": "title 1", "user_id": "nologin"},\n                {"_id": "2", "id": "2", "title": "title 2", "user_id": "nologin"},\n            ]\n        )\n\n    def test_get_todo_all(self, test_app: TestClient):\n        response = test_app.get("/todos")\n        items = response.json()\n\n        assert response.status_code == HTTP_200_OK\n        assert len(items) == 2\n        assert items[0]["id"] == "1"\n        assert items[0]["title"] == "title 1"\n        assert items[1]["id"] == "2"\n        assert items[1]["title"] == "title 2"\n\n    def test_get_todo_by_id(self, test_app: TestClient):\n        response = test_app.get("/todos/1")\n\n        assert response.status_code == HTTP_200_OK\n        assert response.json()["id"] == "1"\n        assert response.json()["title"] == "title 1"\n\n    def test_get_todo_should_return_not_found(self, test_app: TestClient):\n        response = test_app.get("/todos/unknown")\n        assert response.status_code == HTTP_404_NOT_FOUND\n\n    def test_add_todo(self, test_app: TestClient):\n        response = test_app.post("/todos", json={"title": "title 3"})\n        item = response.json()\n\n        assert response.status_code == HTTP_200_OK\n        assert item["title"] == "title 3"\n\n    def test_add_todo_should_return_unprocessable_when_invalid_entity(self, test_app: TestClient):\n        response = test_app.post("/todos", json=None)\n\n        assert response.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_update_todo(self, test_app):\n        response = test_app.put("/todos/1", json={"title": "title 1 updated", "is_completed": False})\n\n        assert response.status_code == HTTP_200_OK\n        assert response.json()["success"]\n\n    def test_update_todo_should_return_not_found(self, test_app):\n        response = test_app.put("/todos/unknown", json={"title": "something", "is_completed": False})\n        assert response.status_code == HTTP_404_NOT_FOUND\n\n    def test_update_todo_should_return_unprocessable_when_invalid_entity(self, test_app: TestClient):\n        response = test_app.put("/todos/1", json={"title": ""})\n\n        assert response.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n    def test_delete_todo(self, test_app: TestClient):\n        response = test_app.delete("/todos/1")\n\n        assert response.status_code == HTTP_200_OK\n        assert response.json()["success"]\n\n    def test_delete_todo_should_return_not_found(self, test_app: TestClient):\n        response = test_app.delete("/todos/unknown")\n        assert response.status_code == HTTP_404_NOT_FOUND\n',p={},l="Controller",_={},u=[{value:"Testing controllers",id:"testing-controllers",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"controller",children:"Controller"})}),"\n",(0,n.jsx)(t.p,{children:"A controller receives a request, then calls a use case, before finally returning a response."}),"\n",(0,n.jsx)(t.p,{children:"The controller (adapter layer) is responsible for validating and transforming requests into an understandable format for the use cases (application layer). The format is defined inside the use cases by the request and response models. The controller takes the user input (the request), converts it into the request model defined by the use case and passes the request model to the use case, and at the end return the response model."}),"\n","\n","\n",(0,n.jsx)(d.A,{language:"jsx",children:i}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"Required"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The controller needs to be decorated with the ",(0,n.jsx)(t.code,{children:"create_response"})," decorator, which handles exceptions and returns a unified response type."]}),"\n",(0,n.jsxs)(t.li,{children:["The controller needs to have set the ",(0,n.jsx)(t.code,{children:"response_model"})," and ",(0,n.jsx)(t.code,{children:"request_model"}),", that is used to generate API documentation and used for validation."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"Optional"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Add ",(0,n.jsx)(t.a,{href:"/template-fastapi-react/docs/contribute/development-guide/coding/extending-the-api/adding-data-providers/repository-interfaces",children:"repository interface"})," to handle communication to external services such as databases and inject the repository implementations to the controller endpoint and pass the injected repository implementations to the use case."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["FastAPI is built around the ",(0,n.jsx)(t.a,{href:"https://github.com/OAI/OpenAPI-Specification",children:"OpenAPI Specification"})," (formerly known as swagger) standards. In FastAPI, by coding your endpoints, you are automatically writing your API documentation. FastAPI maps your endpoint details to a ",(0,n.jsx)(t.a,{href:"https://json-schema.org/",children:"JSON Schema"})," document.  Under the hood, FastAPI uses Pydantic for data validation. With Pydantic along with ",(0,n.jsx)(t.a,{href:"https://docs.python.org/3/library/typing.html",children:"type hints"}),", you get a nice editor experience with autocompletion."]})}),"\n",(0,n.jsx)(t.h2,{id:"testing-controllers",children:"Testing controllers"}),"\n",(0,n.jsxs)(t.p,{children:["Use the ",(0,n.jsx)(t.code,{children:"test_client"})," fixture to populate the database with test data and ",(0,n.jsx)(t.code,{children:"test_app"})," fixture to perform REST API calls."]}),"\n","\n",(0,n.jsx)(d.A,{language:"jsx",children:a}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsx)(t.p,{children:"Mark it as integration test."})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);